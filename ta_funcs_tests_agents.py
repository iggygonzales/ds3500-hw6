"""HW6 Nature-Inspired ComputingGabrielle Bambalan, Desiree DeGennaro, Zoe Chapman, Miguel (Iggy) Gonzales"""import randomimport pandas as pdimport numpy as npimport pytestta = pd.read_csv('tas.csv')sections = pd.read_csv('sections.csv')test1 = pd.read_csv('test1.csv', header=None)test2 = pd.read_csv('test2.csv', header=None)test3 = pd.read_csv('test3.csv', header=None)""" Functions """def overallocation(solution):    max_assigned = ta['max_assigned']    assigned_sections_count = solution.sum(axis=1)    overallocation = assigned_sections_count - max_assigned    # considers only positive overallocations    overallocation_penalty = overallocation[overallocation > 0].sum()    return overallocation_penaltydef conflicts(solution):    section_assignments = np.array(solution)    num_assigned_tas_per_section = np.sum(section_assignments, axis=0)    num_conflicts = np.sum(num_assigned_tas_per_section > 1)    return num_conflictsdef undersupport(solution):    total_penalty = 0    solution = np.array(solution)    min_assigned = sections['min_ta']    assigned_tas = map(lambda col: np.sum(solution[:, col]), range(solution.shape[1]))    ta_difference = map(lambda idx, assigned_tas: max(min_assigned[idx] - assigned_tas, 0),                        range(len(min_assigned)), assigned_tas)    total_penalty = sum(ta_difference)    return total_penaltydef unwilling(solution):    ta_array = np.array((ta.loc[:, '0':'16']))    solution = np.array(solution)    total_unwilling = np.sum((ta_array == 'U') & (solution == 1))    return total_unwillingdef unpreferred(solution):    ta_array = np.array((ta.loc[:, '0':'16']))    solution = np.array(solution)    total_unpreferred = np.sum((ta_array == 'W') & (solution == 1))    return total_unpreferred""" Test """def test(function, input_data, expected_value):    assert function(input_data) == expected_value""" Agents """class Solution:    def __init__(self, allocation):        self.allocation = allocationdef generate_initial_solution(num_tas, sections):    initial_allocation = {}    for ta in range(1, num_tas + 1):        initial_allocation[ta] = random.sample(sections, random.randint(1, len(sections)))    return Solution(initial_allocation)def modify_solution(solution, agent):    return agent.modify(solution)class RandomAgent:    def __init__(self, sections):        self.sections = sections    def modify(self, solution):        ta_to_modify = random.choice(list(solution.allocation.keys()))        new_allocation = random.sample(self.sections, random.randint(1, len(self.sections)))        solution.allocation[ta_to_modify] = new_allocation        return solutionclass GreedyAgent:    def __init__(self, sections):        self.sections = sections    def modify(self, solution):        objectives = [overallocation, conflicts, undersupport, unwilling, unpreferred]        best_solution = solution        best_objective_values = [objective(best_solution.allocation) for objective in objectives]        for ta, assigned_sections in solution.allocation.items():            for section in self.sections:                if section not in assigned_sections:                    new_allocation = solution.allocation.copy()                    new_allocation[ta] = assigned_sections + [section]                    new_solution = Solution(new_allocation)                    new_objective_values = [objective(new_solution.allocation) for objective in objectives]                    if all(new_value <= old_value for new_value, old_value in                           zip(new_objective_values, best_objective_values)):                        best_solution = new_solution                        best_objective_values = new_objective_values        return best_solution# pareto-optimal solutionsnum_tas = len(ta)sections_list = list(sections['section'])num_solutions = 100solutions = []greedy_agent = GreedyAgent(sections_list)for _ in range(num_solutions):    initial_solution = generate_initial_solution(num_tas, sections_list)    pareto_optimal_solution = modify_solution(initial_solution, greedy_agent)    solutions.append(pareto_optimal_solution)# calc objective scoresobjective_scores = []for solution in solutions:    scores = {        'overallocation': overallocation(solution.allocation),        'conflicts': conflicts(solution.allocation),        'undersupport': undersupport(solution.allocation),        'unwilling': unwilling(solution.allocation),        'unpreferred': unpreferred(solution.allocation)    }    objective_scores.append(scores)# create df to csvdata = {    'groupname': 'GroupName',    'overallocation': [objective_scores[i]['overallocation'] for i in range(len(solutions))],    'conflicts': [objective_scores[i]['conflicts'] for i in range(len(solutions))],    'undersupport': [objective_scores[i]['undersupport'] for i in range(len(solutions))],    'unwilling': [objective_scores[i]['unwilling'] for i in range(len(solutions))],    'unpreferred': [objective_scores[i]['unpreferred'] for i in range(len(solutions))]}df = pd.DataFrame(data)df.to_csv('pareto_optimal_solutions.csv', index=False)def main():    " Undersupport Tests "    test_under1 = test(undersupport, test1, 1)    test_under2 = test(undersupport, test2, 0)    test_under3 = test(undersupport, test3, 7)    " Unwilling Tests "    test_unwilling1 = test(unwilling, test1, 53)    test_unwilling2 = test(unwilling, test2, 58)    test_unwilling3 = test(unwilling, test3, 43)    " Unpreffered Tests "    test_unpreferred1 = test(unpreferred, test1, 15)    test_unpreferred2 = test(unpreferred, test2, 19)    test_unpreferred3 = test(unpreferred, test3, 10)    " Conflict Tests "    # test_conflict1 = test(conflicts, test1, 37)    # test_conflict2 = test(conflicts, test2, 41)    # test_conflict3 = test(conflicts, test3, 23)    " Overallocation Tests "    # test_overallocation1 = test(overallocation, test1, 8)    # test_overallocation2 = test(overallocation, test2, 5)    # test_overallocation3 = test(overallocation, test3, 2)main()